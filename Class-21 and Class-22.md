# Class-21 and Class-22 Summary

Booking Service – Advanced Querying and Professional REST Architecture

---

# 1. What We Have Done So Far

Until Class-19, we built:

* Entities (User, Address, Booking, Role)
* JPA Relationships
* Cascade Types
* orphanRemoval
* Thymeleaf UI

Now in Class-21 and Class-22, we upgraded our project to production level.

We improved:

* Query capabilities
* Performance handling
* API design
* Validation
* Error handling
* Clean architecture

---

# 2. Class-21: Advanced Queries in Spring Data JPA

## Topics Covered

* Sorting
* Pagination
* Pageable and Page
* Custom Queries using @Query
* Native Queries
* @NamedQuery and @NamedNativeQuery
* EntityGraph for lazy loading fix

---

# 3. Sorting

## What is Sorting?

Sorting arranges records in ascending or descending order.

Example:

Sort users by name alphabetically.

---

## What We Changed

File Modified:

UserRepository.java
UserController.java

We added:

```java
List<User> findAllWithAddressSorted(Sort sort);
```

And in controller:

```java
Sort.by(Sort.Direction.ASC, "name")
```

---

## What Students Should Understand

Instead of writing SQL:

```
SELECT * FROM users ORDER BY name ASC
```

Spring Data allows:

```
Sort.by("name")
```

Spring automatically generates ORDER BY query.

---

# 4. Pagination

## What is Pagination?

Pagination divides large data into smaller pages.

Example:

If there are 100 users,
Show only 5 per page.

---

## What We Changed

In Controller:

```java
PageRequest.of(page, size);
```

In Repository:

```java
Page<User> findAll(Pageable pageable);
```

---

## What Happens Internally

Spring generates two queries:

```
SELECT * FROM users LIMIT 5 OFFSET 0
SELECT COUNT(*) FROM users
```

---

## Why Pagination is Important

* Prevents loading huge data into memory
* Improves performance
* Used in all production systems

---

# 5. Why We Used @Query

## What is @Query?

@Query allows writing custom JPQL queries.

Example:

```java
@Query("SELECT u FROM User u WHERE u.email = :email")
```

---

## Why We Used It

Because:

* Derived methods are limited
* Sometimes we need custom filtering
* Sometimes we need joins
* We want more control

---

## Difference Between Derived Method and @Query

Derived Method:

```
findByEmail(String email)
```

Auto-generated by Spring.

@Query:

Manual query writing with more control.

---

# 6. Why We Used Native Query

## What is Native Query?

Native Query is real SQL.

Example:

```java
@Query(value = "SELECT * FROM users", nativeQuery = true)
```

---

## Why Use Native Query?

Use it when:

* Complex SQL required
* Database-specific functions needed
* Performance tuning required
* Window functions required

---

## Difference Between JPQL and Native

JPQL:

* Uses entity names
* Database independent

Native:

* Uses table names
* Database specific

---

# 7. Lazy Loading Issue and Fix

We faced an error when sorting and paginating.

Error happened because:

Address relationship was LAZY.

Thymeleaf tried to access:

```
user.address.city
```

But session was closed.

---

## What We Did to Fix It

We used:

@EntityGraph

In UserRepository:

```java
@EntityGraph(attributePaths = {"address"})
```

This forces Hibernate to fetch address with user.

---

## What Students Must Remember

Lazy loading is powerful,
But must be handled carefully.

Use:

* DTO
* JOIN FETCH
* EntityGraph

---

# 8. Class-22: Professional REST Improvements

---

## Topics Covered

* DTO Layer
* Validation using @Valid
* Global Exception Handling
* Clean REST API
* CORS Configuration

---

# 9. Why DTO?

DTO = Data Transfer Object.

We do not expose Entity directly.

Why?

* Security
* Hide internal fields
* Prevent lazy loading problems
* Control API structure

---

## What File We Created

UserDTO.java

---

# 10. Validation

We added:

```java
@NotBlank
@Email
@Size
```

Now invalid input returns 400 automatically.

---

## Why Validation is Important

* Prevent bad data
* Improve API reliability
* Production requirement

---

# 11. Global Exception Handler

We created:

GlobalExceptionHandler.java

Purpose:

* Handle validation errors
* Return clean error messages
* Avoid messy stack traces

---

# 12. HLD (High Level Design)

We improved architecture to this:

Client
→ Controller
→ Service
→ Repository
→ Hibernate
→ Database

Each layer has responsibility.

Controller: Handles request
Service: Business logic
Repository: Data access
Hibernate: ORM
Database: Storage

---

# 13. What Files We Modified

UserRepository.java
UserController.java
UserDTO.java
GlobalExceptionHandler.java
users.html

---

# 14. What Students Should Remember From These Classes

Sorting and Pagination are must in real systems.

@Query gives flexibility.

Native query gives full SQL control.

Lazy loading must be handled carefully.

DTO prevents security and performance issues.

Validation protects data integrity.

Exception handling improves API quality.

---

# 15. In Simple Words

Earlier:

We were just saving and fetching data.

Now:

We are building a professional application.

We added:

Performance control
Data safety
Clean architecture
Production practices

This is how real companies build Spring Boot applications.

---

If you want next, I can prepare:

Class-23 (Spring Security) in the same DOC-ready professional format.
